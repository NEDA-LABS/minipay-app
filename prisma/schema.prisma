generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id               String            @id @default(uuid())
  email            String?           @unique
  wallet           String?           @unique
  privyUserId      String            @unique
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  isActive         Boolean           @default(true)
  name             String?
  apiKeys          ApiKey[]
  merchantSettings MerchantSettings?
  sumsubApplications SumsubApplication[]
  referrals        Referral[]

  // referrals
  influencerProfile    InfluencerProfile?

  //cookies
  cookieConsent      CookieConsent?

  // IDRX onboarding (one-to-one)
  idrxOnboarded     IdrxOnboarded?

  // Smile ID KYC verifications
  smileIdVerifications SmileIDVerification[]

  // Email notifications sent to this user
  emailNotifications EmailNotification[]

  // Contacts - contacts owned by this user (contacts they created)
  ownedContacts     Contact[]  @relation("OwnedContacts")
  
  // Contacts that link to this user (other users saved this user as a contact)
  linkedAsContact   Contact[]  @relation("LinkedContacts")
}

model Referral {
  id                String   @id @default(uuid())
  privyUserId       String   @unique
  user              User     @relation(fields: [privyUserId], references: [privyUserId], onDelete: Cascade)
  influencerCode    String   // customCode from InfluencerProfile
  influencerName    String   // displayName snapshot
  bonusSnapshot     String?  // whatever you promised the invitee
  createdAt         DateTime @default(now())

  @@index([influencerCode])
}

model Counter {
  shard    String   @id // single char A-Z, 2-9
  nextVal  Int      @default(0)
  @@map("referral_counter")
}

model InfluencerProfile {
  id                   String                @id @default(uuid())
  userId               String                @unique
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Influencer details
  displayName          String
  description          String?
  socialLinks          Json?                 // {twitter: "...", instagram: "..."}
  isActive             Boolean               @default(true)
  
  // Referral settings
  customCode           String                @unique // Custom referral code
  
  // Tracking
  totalReferrals       Int                   @default(0)
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  
}

model MerchantSettings {
  id                       String   @id @default(uuid())
  userId                   String   @unique
  businessName             String?
  businessEmail            String?
  businessPhone            String?
  businessCategory         String?
  businessDescription      String?
  autoSettlement           Boolean  @default(true)
  settlementThreshold      Float    @default(1000)
  settlementCurrency       String   @default("TSHC")
  paymentExpiry            Int      @default(60)
  twoFactorEnabled         Boolean  @default(false)
  twoFactorSecret          String?
  withdrawalConfirmation   Boolean  @default(true)
  transactionNotifications Boolean  @default(true)
  settlementNotifications  Boolean  @default(true)
  securityAlerts           Boolean  @default(true)
  marketingUpdates         Boolean  @default(false)
  webhookUrl               String?
  webhookSecret            String?
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt
  user                     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model ApiKey {
  id          String    @id @default(uuid())
  userId      String
  keyId       String    @unique
  hashedKey   String
  environment String
  name        String?
  lastUsed    DateTime?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([keyId])
  @@index([userId, environment])
}

model Transaction {
  id           String        @id @default(uuid())
  merchantId   String
  wallet       String
  amount       Float
  currency     String
  status       String
  txHash       String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  invoiceId    String?       @unique
  network      String?
  orderId      String?
  recipient    String?
  type         String?
  Notification Notification? @relation("TransactionNotification")

  @@index([wallet])
  @@index([currency])
  @@index([createdAt])
  @@index([merchantId, createdAt])
  @@index([txHash])
}

model PaymentLink {
  id           String        @id @default(uuid())
  merchantId   String
  url          String        @unique
  amount       Float?
  currency     String?
  description  String?
  status       String
  createdAt    DateTime      @default(now())
  redeemedAt   DateTime?
  invoiceId    String?       @unique
  expiresAt    DateTime?     // Made optional
  signature    String        @default("")
  linkId       String?       @unique
  invoice      Invoice?      @relation("PaymentLinkInvoice")
  linkType     LinkType      @default(NORMAL) // Added link type
  offRampType  OffRampType?  // Added off-ramp type
  offRampValue String?       // Phone/bank account
  accountName String?       // Phone/bank account
  offRampProvider String?    // MNO/Bank name
  chainId      Int?          // Added chain ID
}

enum LinkType {
  NORMAL
  OFF_RAMP
}

enum OffRampType {
  PHONE
  BANK_ACCOUNT
}

model Notification {
  id                   String       @id @default(uuid())
  message              String
  recipient            String
  type                 String
  status               String
  createdAt            DateTime     @default(now())
  broadcastId          String?
  relatedTransactionId String?      @unique
  relatedTransaction   Transaction? @relation("TransactionNotification", fields: [relatedTransactionId], references: [id])
  broadcastNotification BroadcastNotification? @relation(fields: [broadcastId], references: [id])
}

model Invoice {
  id                String            @id @default(uuid())
  merchantId        String
  recipient         String
  sender            String            @default("not given")
  email             String
  paymentCollection String
  dueDate           DateTime
  currency          String
  totalAmount       Float             @default(0)
  status            String
  createdAt         DateTime          @default(now())
  sentAt            DateTime?
  paidAt            DateTime?
  canceledAt        DateTime?
  paymentLinkId     String?           @unique
  paymentLink       PaymentLink?      @relation("PaymentLinkInvoice", fields: [paymentLinkId], references: [id])
  lineItems         InvoiceLineItem[]
}

model InvoiceLineItem {
  id          String   @id @default(uuid())
  invoiceId   String
  description String
  amount      Float    @default(0)
  createdAt   DateTime @default(now())
  Invoice     Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
}

model OffRampTransaction {
  id           String        @unique
  createdAt    DateTime      @default(now()) 
  merchantId   String
  status       String
  amount       String        @default("...")
  rate         String        @default("2460")
  currency     String        @default("...")
  accountName  String        @default("...")
  accountNumber String       @default("...")
  institution  String        @default("...")

  @@index([merchantId])
  @@index([currency])
  @@index([createdAt])
}

// broadcast notification
model BroadcastNotification {
  id        String   @id @default(cuid())
  title     String
  message   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  notifications Notification[]
}

// Store credentials returned from IDRX onboarding securely
model IdrxOnboarded {
  id            String   @id @default(uuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  idrxId        Int
  provider      String   @default("IDRXCO")

  // Encrypted fields (AES-GCM encoded payload)
  apiKeyEnc     String
  apiSecretEnc  String

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([idrxId])
}

//SUMSUB----------------------------------------------------------------------------------------
// Add these enums to your existing schema
enum SumsubVerificationStatus {
  INIT
  PENDING
  QUEUED
  PRECHECKED
  ON_HOLD
  COMPLETED
}

enum SumsubReviewAnswer {
  GREEN   // Approved
  RED     // Rejected
  YELLOW  // Manual review required
}

enum SumsubReviewRejectType {
  FINAL
  RETRY
}

enum SumsubWebhookEventType {
  APPLICANT_CREATED
  APPLICANT_PENDING
  APPLICANT_REVIEWED
  APPLICANT_ON_HOLD
  APPLICANT_RESET
  APPLICANT_DELETED
  VIDEO_IDENT_STATUS_CHANGED
}

// Main Sumsub application tracking
model SumsubApplication {
  id                    String                    @id @default(cuid())
  userId                String
  applicantId           String                    @unique  // Sumsub's applicant ID
  inspectionId          String                    @unique  // Sumsub's inspection ID
  externalUserId        String?                   // Your user ID sent to Sumsub
  levelName             String                    // Sumsub verification level
  applicantType         String?                   // individual, company
  verificationStatus    SumsubVerificationStatus  @default(INIT)
  reviewAnswer          SumsubReviewAnswer?
  reviewRejectType      SumsubReviewRejectType?
  sandboxMode           Boolean                   @default(false)
  
  // Timestamps
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt
  submittedAt           DateTime?                 // When applicant submitted docs
  reviewedAt            DateTime?                 // When review was completed
  
  // Relations
  user                  User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  webhookEvents         SumsubWebhookEvent[]
  reviewHistory         SumsubReviewHistory[]
  
  @@map("sumsub_applications")
}

// Track all webhook events received from Sumsub
model SumsubWebhookEvent {
  id                    String                    @id @default(cuid())
  sumsubApplicationId   String
  correlationId         String                    @unique  // Sumsub's correlation ID for idempotency
  eventType             SumsubWebhookEventType
  payload               Json                      // Store full webhook payload
  processed             Boolean                   @default(false)
  processedAt           DateTime?
  errorMessage          String?                   // If processing failed
  createdAt             DateTime                  @default(now())
  
  // Relations
  sumsubApplication     SumsubApplication         @relation(fields: [sumsubApplicationId], references: [id], onDelete: Cascade)
  
  @@index([correlationId])
  @@index([eventType, createdAt])
  @@map("sumsub_webhook_events")
}

// Track review history and status changes
model SumsubReviewHistory {
  id                    String                    @id @default(cuid())
  sumsubApplicationId   String
  reviewAnswer          SumsubReviewAnswer
  reviewRejectType      SumsubReviewRejectType?
  rejectLabels          String[]                  // Array of rejection reasons
  buttonIds             String[]                  // Sumsub button IDs for rejection reasons
  moderationComment     String?                   // Sumsub's moderation comment
  clientComment         String?                   // Your custom comment
  reviewMode            String?                   // ongoingAML, ongoingDocExpired, etc.
  reviewedAt            DateTime                  @default(now())
  
  // Relations
  sumsubApplication     SumsubApplication         @relation(fields: [sumsubApplicationId], references: [id], onDelete: Cascade)
  
  @@map("sumsub_review_history")
}

//Cookies
model CookieConsent {
id                      String @id @default(uuid())
privyUserId             String @unique // Also store Privy user id for convenience
region                  String? // e.g., "EEA", "UK", "US-CA", "ROW"
version                 String @default("v1")
preferences             Json // { necessary: true, analytics: false, marketing: false }
consentedAt             DateTime @default(now())
updatedAt               DateTime @updatedAt


user User? @relation(fields: [privyUserId], references: [privyUserId], onDelete: Cascade)


@@index([privyUserId])
}

// Admin Settings for controlling platform features
model AdminSettings {
  id                    String   @id @default(uuid())
  
  // Payramp/Paycrest Bank Withdrawal Controls
  allowBankWithdrawals  Json     @default("{\"TZS\": false, \"KES\": true, \"UGX\": true, \"NGN\": true, \"GHS\": true}")
  // Format: { "TZS": false, "KES": true, "UGX": true, "NGN": true, "GHS": true }
  
  // Additional feature flags
  maintenanceMode       Boolean  @default(false)
  allowNewRegistrations Boolean  @default(true)
  
  // Metadata
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  lastModifiedBy        String?  // Admin who last modified
  
  @@map("admin_settings")
}

// ============================================================================
// CONTACTS MANAGEMENT SYSTEM
// ============================================================================

// Contact - Save recipient details for quick transactions
model Contact {
  id                String                 @id @default(uuid())
  userId            String                 // Contact owner (who created this contact)
  user              User                   @relation("OwnedContacts", fields: [userId], references: [id], onDelete: Cascade)
  
  // Optional link to existing NedaPay user (recipient)
  linkedUserId      String?                // If recipient is a NedaPay user
  linkedUser        User?                  @relation("LinkedContacts", fields: [linkedUserId], references: [id], onDelete: SetNull)
  
  // Basic Information
  name              String                 // Display name
  nickname          String?                // Optional nickname
  country           String?                // ISO country code (TZ, KE, etc) - optional
  notes             String?                // User notes
  isNedaPayUser     Boolean                @default(false) // Quick flag for linked users
  
  // Relations
  bankAccounts      ContactBankAccount[]
  phoneNumbers      ContactPhoneNumber[]
  cryptoAddresses   ContactCryptoAddress[]
  
  // Metadata
  favorite          Boolean                @default(false)
  lastUsed          DateTime?
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt
  
  @@index([userId])
  @@index([userId, name])
  @@index([userId, favorite])
  @@index([userId, lastUsed])
  @@index([linkedUserId])
}

// ContactBankAccount - Bank account details for a contact
model ContactBankAccount {
  id                String    @id @default(uuid())
  contactId         String
  contact           Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)
  
  // Bank Account Details
  accountNumber     String
  accountName       String    // Account holder name
  bankName          String    // Institution name
  bankCode          String?   // Bank identifier/code
  currency          String    @default("TZS") // Account currency
  
  // Metadata
  isPrimary         Boolean   @default(false) // Primary account for this contact
  isVerified        Boolean   @default(false) // Has been used successfully
  label             String?   // User-defined label (e.g., "Salary Account")
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  @@index([contactId])
  @@index([contactId, isPrimary])
}

// ContactPhoneNumber - Phone number details for a contact
model ContactPhoneNumber {
  id                String    @id @default(uuid())
  contactId         String
  contact           Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)
  
  // Phone Number Details
  phoneNumber       String    // E.164 format (e.g., +255712345678)
  provider          String?   // MNO (Mobile Network Operator) name - optional
  country           String?   // ISO country code - optional
  
  // Metadata
  isPrimary         Boolean   @default(false)
  isVerified        Boolean   @default(false)
  label             String?   // User-defined label (e.g., "Work Phone")
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  @@index([contactId])
  @@index([contactId, isPrimary])
}

// ContactCryptoAddress - Cryptocurrency address details for a contact
model ContactCryptoAddress {
  id                String    @id @default(uuid())
  contactId         String
  contact           Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)
  
  // Crypto Address Details
  address           String    // Wallet address (0x...)
  ensName           String?   // ENS name if available
  chainId           Int?      // Preferred chain ID
  
  // Metadata
  isPrimary         Boolean   @default(false)
  isVerified        Boolean   @default(false)
  label             String?   // User-defined label (e.g., "Hardware Wallet")
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  @@index([contactId])
  @@index([contactId, isPrimary])
  @@index([address])
}

// ============================================================================
// SMILE ID KYC INTEGRATION
// ============================================================================

enum SmileIDVerificationStatus {
  PENDING
  SUCCESS
  FAILED
  EXPIRED
}

enum SmileIDVerificationMethod {
  DOC_VERIFICATION     // Document verification only
  BIOMETRIC_KYC       // Document + biometric matching
}

// Main Smile ID verification tracking
model SmileIDVerification {
  id                    String                      @id @default(cuid())
  userId                String
  privyUserId           String                      @unique // Use Privy ID instead of wallet
  platform              String                      @default("smile_id")
  platformRef           String                      // Smile ID reference ID
  verificationUrl       String                      // Smile Link URL
  status                SmileIDVerificationStatus   @default(PENDING)
  
  // Verification details
  country               String?                     // ISO country code
  idType                String?                     // ID document type
  verificationMethod    SmileIDVerificationMethod?  // Verification method used
  
  // Results
  resultCode            String?                     // Smile ID result code
  resultText            String?                     // Smile ID result description
  
  // Email notification tracking
  emailSent             Boolean                     @default(false)
  emailSentAt           DateTime?
  
  // Timestamps
  expiresAt             DateTime                    // When verification URL expires
  createdAt             DateTime                    @default(now())
  updatedAt             DateTime                    @updatedAt
  submittedAt           DateTime?                   // When user submitted documents
  completedAt           DateTime?                   // When verification completed
  
  // Relations
  user                  User                        @relation(fields: [userId], references: [id], onDelete: Cascade)
  webhookEvents         SmileIDWebhookEvent[]
  
  @@index([privyUserId])
  @@index([userId])
  @@index([status])
  @@index([platformRef])
  @@map("smile_id_verifications")
}

// Track all webhook events from Smile ID
model SmileIDWebhookEvent {
  id                    String                @id @default(cuid())
  smileIdVerificationId String
  correlationId         String?               // For idempotency
  resultCode            String                // Smile ID result code
  resultText            String?               // Result description
  payload               Json                  // Full webhook payload
  signature             String                // Webhook signature for validation
  processed             Boolean               @default(false)
  processedAt           DateTime?
  errorMessage          String?               // If processing failed
  createdAt             DateTime              @default(now())
  
  // Relations
  smileIdVerification   SmileIDVerification   @relation(fields: [smileIdVerificationId], references: [id], onDelete: Cascade)
  
  @@index([smileIdVerificationId])
  @@index([resultCode])
  @@index([createdAt])
  @@map("smile_id_webhook_events")
}

// Store supported ID types configuration
model SmileIDSupportedType {
  id                    String                      @id @default(cuid())
  country               String                      // ISO country code
  countryName           String                      // Full country name
  idType                String                      // ID document type
  verificationMethod    SmileIDVerificationMethod   // Supported verification method
  isActive              Boolean                     @default(true)
  createdAt             DateTime                    @default(now())
  updatedAt             DateTime                    @updatedAt
  
  @@unique([country, idType])
  @@index([country])
  @@index([verificationMethod])
  @@map("smile_id_supported_types")
}

// ============================================================================
// EMAIL NOTIFICATION TRACKING
// ============================================================================

enum EmailNotificationType {
  INVOICE_SENT
  WELCOME
  KYC_REMINDER
  KYC_STATUS_APPROVED
  KYC_STATUS_REJECTED
  KYC_STATUS_PENDING
  KYC_STATUS_ADDITIONAL_INFO
  PASSWORD_RESET
  PAYMENT_RECEIVED
  WITHDRAWAL_PROCESSED
}

enum EmailNotificationStatus {
  PENDING
  SENT
  FAILED
  BOUNCED
  DELIVERED
}

// Track all emails sent by the system
model EmailNotification {
  id                    String                      @id @default(cuid())
  userId                String?                     // Related user (optional)
  recipientEmail        String                      // Email address
  recipientName         String?                     // Recipient name
  
  // Email details
  type                  EmailNotificationType       // Type of email
  subject               String                      // Email subject
  status                EmailNotificationStatus     @default(PENDING)
  
  // Provider details
  providerMessageId     String?                     // Message ID from email provider (e.g., Resend)
  providerResponse      Json?                       // Full response from provider
  
  // Error tracking
  errorMessage          String?                     // Error if send failed
  retryCount            Int                         @default(0)
  maxRetries            Int                         @default(3)
  
  // Metadata
  metadata              Json?                       // Additional context (e.g., invoice ID, KYC status)
  
  // Timestamps
  createdAt             DateTime                    @default(now())
  sentAt                DateTime?
  deliveredAt           DateTime?
  failedAt              DateTime?
  
  // Relations
  user                  User?                       @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([recipientEmail])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@map("email_notifications")
}

